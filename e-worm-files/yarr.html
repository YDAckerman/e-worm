<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2023-11-27 Mon 10:06 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="yoni" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="style.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<p>
<a href="https://yoni.e-worm.club/">&lt; index</a>
</p>

<div id="outline-container-orgeff866b" class="outline-2">
<h2 id="orgeff866b"><span class="section-number-2">1</span> Yarr Notes</h2>
<div class="outline-text-2" id="text-1">
<p>
<a href="https://yetanotherrustresource.com/">&gt; yarr</a>
</p>

<p>
Why am I doing this??
</p>

<blockquote>
<p>
"No one is going to hire you to write rust" - people &gt; 0
</p>
</blockquote>

<blockquote>
<p>
"Because a buddha is in birth and death, there is no birth and death&#x2026; Because a buddha is not in birth and death, a buddha is not deluded by birth and death" - Eihei Dogen
</p>
</blockquote>

<p>
I apologize for the many misspellings.
</p>
</div>
</div>

<div id="outline-container-orgdc60df3" class="outline-2">
<h2 id="orgdc60df3"><span class="section-number-2">2</span> Yarr!</h2>
<div class="outline-text-2" id="text-2">
<ul class="org-ul">
<li>rust analyzer is very cool. I like how it looks. feels cozy and friendly.</li>

<li>Makes me think I should train an llm. Make a weird cameo study-buddy
for myself.</li>

<li>basic cargo commands</li>
</ul>

<p>
run your thing. compile your thing and run. 
</p>

<div class="org-src-container">
<pre class="src src-bash">cargo run
</pre>
</div>

<ul class="org-ul">
<li>println!</li>
</ul>

<p>
this is macro syntax bruh.
</p>

<p>
here is src: 
</p>

<div class="org-src-container">
<pre class="src src-rust">macro_rules! println {
    () =&gt; { ... };
    ($($arg:tt)*) =&gt; { ... };
}
</pre>
</div>

<p>
wut. this looks like a match statement. like, are those two cases?
$arg is suggestive. * reminds me of a wild card. { &#x2026; } could mean anything.
</p>

<p>
same syntax as format! but prints to stdout instead. 
</p>

<p>
bad in hot loops! what is a hot loop?
</p>

<p>
what is a hot loop???
</p>

<p>
what is a hot loop???
</p>

<p>
what is a hot loop???
</p>

<div class="org-src-container">
<pre class="src src-rust">io::stdout().lock();
</pre>
</div>

<p>
wut?? OH!!! COOL!:
</p>

<div class="org-src-container">
<pre class="src src-rust">use std::io::{stdout, Write};

let mut lock = stdout().lock();
writeln!(lock, "hello world").unwrap();
</pre>
</div>

<p>
BROOOOO. from std docks:
</p>

<p>
" Access is also synchronized via a lock and explicit control over
locking is available via the lock method."
</p>

<p>
So a lock grants access. like, by definition, so. ok. The owner has
the lock, no one else can access that resource.
</p>

<p>
example? 
</p>

<div class="org-src-container">
<pre class="src src-rust">use std::io::{self, Write};

fn main() -&gt; io::Result&lt;()&gt; {
    let mut stdout = io::stdout().lock();

    stdout.write_all(b"hello world")?;

    Ok(())
}
</pre>
</div>

<p>
is it tho? I think it is just showing basic usage. not an
exemplary case. Because I could just write hello world without a
lock&#x2026; right? Maybe missing something
</p>

<ul class="org-ul">
<li>eprintln! is for errors and progress messages (goes to stderr, i assume?).</li>

<li>check out the extreme cases on each side of the (optimized) spectrum on leetcode.</li>
</ul>
</div>

<div id="outline-container-orge2e4afc" class="outline-3">
<h3 id="orge2e4afc"><span class="section-number-3">2.1</span> variables! (not a macro)</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>let mut! (also not a macro)</li>

<li>mutability means exclusive access. LIKE LOCKS. FOR DOORS.</li>
</ul>
</div>

<div id="outline-container-orgfc8f8e3" class="outline-4">
<h4 id="orgfc8f8e3"><span class="section-number-4">2.1.1</span> Type annotations</h4>
<div class="outline-text-4" id="text-2-1-1">
<ul class="org-ul">
<li>statically typed lengua: we've all got types at compile time. woo.</li>
<li>type inference - compiler can figure some stuff out.</li>
<li>rust-analyzer tells you what types are inferred, which is SO
helpful.</li>
</ul>
</div>
</div>

<div id="outline-container-org25fef93" class="outline-4">
<h4 id="org25fef93"><span class="section-number-4">2.1.2</span> primitive types.</h4>
<div class="outline-text-4" id="text-2-1-2">
<ul class="org-ul">
<li>u8, u16, u32, u64, u128, usize. usize is a pointer-sized unsigned
integer. used to index into collections. good to knoooooo.</li>
<li>i8 &#x2026; i128, isize. isize is a pointer-sized signed integer. handy
for representing the difference between two indexes. ah!</li>
<li>f32, f64. floating point ums. 1.2f32 or 1.2f64</li>
<li>char. 4 byes!</li>
<li>bool. hire me i know what a bool is!</li>
<li>str. utf-8 encoded string slice. &amp;str. utf-8 makes accessing chars
at different indices more complicated.</li>
<li>(). r/absoluteunit</li>
</ul>
</div>
</div>

<div id="outline-container-org9983b39" class="outline-4">
<h4 id="org9983b39"><span class="section-number-4">2.1.3</span> tuples arrays</h4>
<div class="outline-text-4" id="text-2-1-3">
<ul class="org-ul">
<li>tuple (u8, bool)</li>
<li>arrays. fixed size. [u8; 5]</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org3a0ea99" class="outline-3">
<h3 id="org3a0ea99"><span class="section-number-3">2.2</span> Casting</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>as &lt;type&gt;</li>
</ul>
</div>
</div>

<div id="outline-container-org3cca070" class="outline-3">
<h3 id="org3cca070"><span class="section-number-3">2.3</span> Control Flow</h3>
<div class="outline-text-3" id="text-2-3">
<ul class="org-ul">
<li>'blocks delimit a scope'</li>
<li>'blocks return a value'</li>
<li>use blocks to release resources</li>
</ul>

<p>
cool
</p>

<ul class="org-ul">
<li>if</li>
<li>loop, while, for</li>
</ul>
</div>
</div>

<div id="outline-container-orgca998fa" class="outline-3">
<h3 id="orgca998fa"><span class="section-number-3">2.4</span> fun</h3>
<div class="outline-text-3" id="text-2-4">
<p>
wow this resource was worth it just for introducing me to rust-analyzer. 
</p>
</div>
</div>

<div id="outline-container-org68dd5d4" class="outline-3">
<h3 id="org68dd5d4"><span class="section-number-3">2.5</span> memory management</h3>
<div class="outline-text-3" id="text-2-5">
<ul class="org-ul">
<li>stack! this is where you put plates. things on the stack only live as long as the function they are inside.</li>
<li>heap! this is where you find needles in O(1). things can live here until they are deallocated. this has to happen deliberately.</li>

<li>flavors: manual memory management, automatic memory management (garbage collection [java, go], reference counting [python, swift])</li>

<li>Rust does manual memory management via ownership. so neoclassical.</li>
</ul>
</div>

<div id="outline-container-orgccb2dc4" class="outline-4">
<h4 id="orgccb2dc4"><span class="section-number-4">2.5.1</span> References and poincares.</h4>
<div class="outline-text-4" id="text-2-5-1">
<ul class="org-ul">
<li>x is x, &amp;x is a reference to x, *x references the reference to the
underlying value.</li>
</ul>

<div class="org-src-container">
<pre class="src src-rust">let x: u32 = 10;

let ref_x: &amp;u32 = &amp;x;

println!("x = {}", *ref_x);
</pre>
</div>

<p>
Rust will usually dereference for you:
</p>

<div class="org-src-container">
<pre class="src src-rust">println!("x = {}", ref_x);
</pre>
</div>

<ul class="org-ul">
<li>pointers are like references, but come with fewer guarantees. They
are JUST an address in memory. so you can do unsafe things with
them. Not really in the scope of yarr.</li>
</ul>
</div>
</div>

<div id="outline-container-orged83429" class="outline-4">
<h4 id="orged83429"><span class="section-number-4">2.5.2</span> Heap Allocation</h4>
<div class="outline-text-4" id="text-2-5-2">
<ul class="org-ul">
<li>Box</li>
</ul>

<div class="org-src-container">
<pre class="src src-rust">let x: Box&lt;u32&gt; = Box::new(42);
let y = Box::&lt;f64&gt;::new(4.2);
</pre>
</div>

<ul class="org-ul">
<li>deref that box:</li>
</ul>

<div class="org-src-container">
<pre class="src src-rust">let z = *x;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org97c2ab9" class="outline-3">
<h3 id="org97c2ab9"><span class="section-number-3">2.6</span> Collections</h3>
<div class="outline-text-3" id="text-2-6">
</div>
<div id="outline-container-org4a6fda9" class="outline-4">
<h4 id="org4a6fda9"><span class="section-number-4">2.6.1</span> Vecs</h4>
<div class="outline-text-4" id="text-2-6-1">
<div class="org-src-container">
<pre class="src src-rust">
let mut menu: Vec&lt;&amp;str&gt; = Vec::new();
menu.push("meat");
println!("looks like {:?}'s back on the menu, boys!", menu);

let mut menu = vec!["meat"];

menu.push("meat");
menu.push("meat");
menu.push("meat");

for &amp;menu_item in menu.iter() {
    println!("looks like {}'s back on the menu, boys!", menu_item);
}

</pre>
</div>
</div>
</div>

<div id="outline-container-orge809a02" class="outline-4">
<h4 id="orge809a02"><span class="section-number-4">2.6.2</span> other</h4>
<div class="outline-text-4" id="text-2-6-2">
<ul class="org-ul">
<li>HashMap</li>
<li>BTreeMap</li>
<li>HashSet</li>
<li>BTreeSet</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgaa18938" class="outline-3">
<h3 id="orgaa18938"><span class="section-number-3">2.7</span> Ownership and lifetimes</h3>
<div class="outline-text-3" id="text-2-7">
<ul class="org-ul">
<li>ownership is used for tracking when memory is valid and when it is
dropped.</li>
<li>the lifetime of a variable is the time when references to it are
valid.</li>
</ul>
</div>
</div>

<div id="outline-container-org2faf2f4" class="outline-3">
<h3 id="org2faf2f4"><span class="section-number-3">2.8</span> Lifetimes</h3>
<div class="outline-text-3" id="text-2-8">
<p>
&gt; "These are still things that disintegrate. What is the indestructible nature?" - some monk to Joshu
</p>


<ul class="org-ul">
<li>"Every reference is a borrow, and each borrow has a lifetime. That
lifetime spans from when the variable is created to when it is
destroyed."</li>
</ul>

<p>
Which is to say, if you have a reference to something, you're
borrowing it (mutably or immutably). you can borrow it only so long as
that thing exists. And thus a borrow has a lifetime spanning the birth
and death of the thing. 
</p>

<ul class="org-ul">
<li>the borrow checker makes sure every reference has a lifetime WHOLLY
contained in the borrowed value's lifetime.</li>
</ul>

<div class="org-src-container">
<pre class="src src-rust">fn example&lt;'a&gt;(x: &amp;'a u32) {
   let y: &amp;'a u32 = &amp;x;
}
</pre>
</div>

<p>
does this mean y is a reference to a reference?
</p>

<ul class="org-ul">
<li>generics: &lt;'a&gt;</li>
<li>'static means "referred to data will live for the duration of the
program"</li>
</ul>

<p>
constants:
</p>

<div class="org-src-container">
<pre class="src src-rust">let msg: &amp;'static str = "hello, wordl!";
</pre>
</div>

<ul class="org-ul">
<li>anywhere type annotation can go, an explicit lifetime can go too.</li>

<li>lifetime elision. Compiler guesses based on rules.</li>
</ul>
</div>
</div>

<div id="outline-container-org668163a" class="outline-3">
<h3 id="org668163a"><span class="section-number-3">2.9</span> Ownership</h3>
<div class="outline-text-3" id="text-2-9">
<ul class="org-ul">
<li>I think I misunderstood something before. Variables don't own
things. Scopes own things and scopes borrow things. That's helpful.</li>

<li>copy. Some types implement the copy trait. These types types get
copied instead of being moved, which means you can keep using it in
both 'places'. ie:</li>
</ul>

<div class="org-src-container">
<pre class="src src-rust">let x: u32 = 10;
println!("x is {x}");
println!("x*2 is {}", x*2);
</pre>
</div>

<p>
normally, println! would take ownership of x, meaning we couldn't
reference x anymore after the completion of println!'s scope. But
because x 'is Copy' here, we can keep using it because it is copied
into the scope of println! instead of moved. Realizing this in vivo requires
understanding the types and their respective traits as you pass them
around.
</p>
</div>
</div>

<div id="outline-container-org71e034d" class="outline-3">
<h3 id="org71e034d"><span class="section-number-3">2.10</span> Closures</h3>
<div class="outline-text-3" id="text-2-10">
<ul class="org-ul">
<li>these are essentially anonymous functions:</li>
</ul>

<div class="org-src-container">
<pre class="src src-rust">let y: u32 = 10;
let annotated = |x: u32| -&gt; u32 { x + y };
let inferred = |x| x + y;

println!("annotated: {}", annotated(32));
println!("inferred: {}", inferred(32));
</pre>
</div>

<ul class="org-ul">
<li>closures can reference values outside their scope. they can also
capture and use them. By, say, getting a value from outside the
scope, and incrementing it. But the closure must be mut if it
captures a mutable variable. It's capturing a mutable variable (the
variable becomes part of the closure) and  it, thus the closure is
changing.</li>

<li>functions can return closures:</li>
</ul>

<div class="org-src-container">
<pre class="src src-rust">fn print_msg&lt;'a&gt;(msg: &amp;'a str) -&gt; impl Fn() + 'a {
        let printer = move || {
          println!("{msg}");
        };
        printer
}

fn make_counter() -&gt; impl FnMut() {
   let mut count = 0;
   let increment = move || {
       count += 1;
       count
   };
   increment
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-rust">
let adder = |a: u32, b: u32 | a + b;

</pre>
</div>
</div>
</div>


<div id="outline-container-org8cf3a1d" class="outline-3">
<h3 id="org8cf3a1d"><span class="section-number-3">2.11</span> Structs</h3>
<div class="outline-text-3" id="text-2-11">
<ul class="org-ul">
<li>struct fields</li>
<li>struct impl blocks</li>
</ul>

<div class="org-src-container">
<pre class="src src-rust">
struct CrewMember {
  name: String,
  age: u32,
  odors: Vec&lt;String&gt;,
}

impl CrewMember {

  pub fn describe(&amp;self) {

  println!("{} is {} and smells like {:?}", self.name, self.age, self.odors)

  }

}


</pre>
</div>
</div>
</div>

<div id="outline-container-org3d0026a" class="outline-3">
<h3 id="org3d0026a"><span class="section-number-3">2.12</span> Enums</h3>
<div class="outline-text-3" id="text-2-12">
<ul class="org-ul">
<li>good</li>
<li>variants: field by position; fields by name; unit variant</li>
<li>pattern matching</li>
</ul>

<div class="org-src-container">
<pre class="src src-rust">
enum Weekdays {
     Monday,
     Tuesday,
     Wednesday,
     Thursday,
     Friday,
}

enum Result&lt;T, E&gt; {
     Ok(T),
     Err(E)
}

</pre>
</div>
</div>
</div>

<div id="outline-container-org3fd09c4" class="outline-3">
<h3 id="org3fd09c4"><span class="section-number-3">2.13</span> More control flow</h3>
<div class="outline-text-3" id="text-2-13">
<div class="org-src-container">
<pre class="src src-rust">
let value = Some(42);

if let Some(inner) = value {
   println!("inner was {inner}");
} else {
   println!("no inner");
}

let vals = vec![1,2,3];
let mut iter = values.iter();

while let Some(v) = iter.next() {
   println!("v = {v}");
}

</pre>
</div>
</div>
</div>

<div id="outline-container-org7a3ff20" class="outline-3">
<h3 id="org7a3ff20"><span class="section-number-3">2.14</span> Modules</h3>
<div class="outline-text-3" id="text-2-14">
<ul class="org-ul">
<li>in a block delimited by braces:</li>
</ul>

<div class="org-src-container">
<pre class="src src-rust">
pub mod math {

    pub fn add(x: u32, y: u32) -&gt; u32 {
        x + y
    }
}

</pre>
</div>

<ul class="org-ul">
<li>in a file at the level of main.rs with the name of the module (ie math.rs). must add pub mod math; to main.rs file.</li>

<li>in a folder (ie math) with a mod.rs file containing the code.</li>
</ul>
</div>

<div id="outline-container-orgb2039f0" class="outline-4">
<h4 id="orgb2039f0"><span class="section-number-4">2.14.1</span> using modules</h4>
<div class="outline-text-4" id="text-2-14-1">
<ul class="org-ul">
<li>use!</li>
<li>use super::thing (parent module) or use crate::thing (from the root of the current crate)</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-org547ae4b" class="outline-2">
<h2 id="org547ae4b"><span class="section-number-2">3</span> Testing</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>create a child module called test.rs :</li>
</ul>

<div class="org-src-container">
<pre class="src src-rust">// only compile if the test compile option is on
#[cfg(test)]
mod tests {

    use super::*;

    #[test]
    fn adds_small_numbers() {
       let x = 10;
       let y = 20;
       let expected = 30;
       assert_eq!(plus(x, y), expected, "should add up correctly");
    }

    // this fails bc function params are i32 in the example.
    #[test]
    fn adds_big_numbers() {
       let x = 2_000_000_000;
       let y = 2_000_000_000;
       assert!(plus(x, y ) &gt; 0, "result should be positive");
    }

}

</pre>
</div>
</div>

<div id="outline-container-org32e79a4" class="outline-4">
<h4 id="org32e79a4"><span class="section-number-4">3.0.1</span> integration tests</h4>
<div class="outline-text-4" id="text-3-0-1">
<ul class="org-ul">
<li>integration tests can only consume the public api of your
library. ex:</li>
</ul>

<div class="org-src-container">
<pre class="src src-rust">
use my_library::plus;

#[test]
fn test_addition() {
   assert_eq!(plus(10, 20), 30);
}

</pre>
</div>
</div>
</div>

<div id="outline-container-orgfe56557" class="outline-4">
<h4 id="orgfe56557"><span class="section-number-4">3.0.2</span> Doc tests</h4>
<div class="outline-text-4" id="text-3-0-2">
<ul class="org-ul">
<li>i hadn't heard of such a thing:</li>
</ul>

<div class="org-src-container">
<pre class="src src-rust">
/// Adds things
///
/// ```
/// use playground::plus;
/// assert_eq!(30, plus(10,20));
/// ```
pub fn plus(x: i32, y: i32) -&gt; i32 { x + y }

</pre>
</div>
</div>
</div>

<div id="outline-container-orgf8e0688" class="outline-3">
<h3 id="orgf8e0688"><span class="section-number-3">3.1</span> Linting and Formatting</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>formatter: cargo-fmt. run with: cargo fmt</li>
<li>linter: clippy. run with: cargo clippy</li>
<li>its usually good to treat clippy warnings as errors.</li>
</ul>
</div>
</div>

<div id="outline-container-orgfff243c" class="outline-3">
<h3 id="orgfff243c"><span class="section-number-3">3.2</span> Dependency Management</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>crates.io</li>
<li>add a dependency to your project with (serde is an example): cargo
add serde.</li>
<li>if you want a specific verion, add serde = "1.0.154" to Cargo.toml</li>
<li>semver: semantic versioning. MAJOR.MINOR.PATCH. changes to MAJOR
imply incompatible API changes. Changes to MINOR imply functionality
added in a backward-compatible manner. Changes to PATCH imply
backward-compatible bug fixes.</li>
</ul>
</div>
</div>

<div id="outline-container-orgbd716e3" class="outline-3">
<h3 id="orgbd716e3"><span class="section-number-3">3.3</span> Traits</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>for defining shared behavior</li>
<li>basically a collection of methods, either abstract or composed of
other trait methods.</li>
<li>abstract methods are then implemented depending on the type</li>
</ul>

<p>
ex:
</p>

<div class="org-src-container">
<pre class="src src-rust">
trait KeyValueStore {

// must be implemented by structs with the KeyValuestore trait
    fn set(&amp;mut self, key: &amp;str, value: Vec&lt;u8&gt;); // I think the value is just an example
    fn get(&amp;mut self, key: &amp;str);
    fn lock(&amp;mut self, key: &amp;str);
    fn unlock(&amp;mut self, key: &amp;str);

    // composed of the above methods
    fn get_and_set(&amp;mut self, key: &amp;str, value: Vec&lt;u8&gt;) -&gt; Option&lt;Vec&lt;u8&gt;&gt; {

       self.lock(key);
       let old_value = self.get(key);
       self.set(key, value);

       self.unlock(key);
       old_value

    }
}

</pre>
</div>

<p>
Note: everything is public by default. 
</p>
</div>

<div id="outline-container-org051bf96" class="outline-4">
<h4 id="org051bf96"><span class="section-number-4">3.3.1</span> example definition and example</h4>
<div class="outline-text-4" id="text-3-3-1">
<div class="org-src-container">
<pre class="src src-rust">
trait Printable {
    fn print(&amp;self);
}

struct Ship {
    name: String
}

impl Printable for Ship {
    fn print(&amp;self) {
        println!("&lt;Ship name=\"{}\"&gt;", self.name);
    }
}

</pre>
</div>

<ul class="org-ul">
<li>some traits can also be derived:</li>
</ul>

<div class="org-src-container">
<pre class="src src-rust">
#[derive(Debug, PartialEq)]
struct PirateShip {
    name: String,
    masts: f32, //1.5 masts apparently makes sense
}

</pre>
</div>

<ul class="org-ul">
<li>you can impl <i>any</i> trait on a type you define. and you can impl a
trait that you define on <i>any</i> type. BUT YOU CANNOT IMPL A TRAIT THAT
YOU DIDN'T DEFINE ON A TYPE THAT YOU DIDN'T DEFINE. don't want
multiple impls floating around.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org73ce682" class="outline-3">
<h3 id="org73ce682"><span class="section-number-3">3.4</span> using traits</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>use methods from a trait on a type that impls it.</li>
<li>accept the trait as parameters to a function or return type</li>
<li>use them as part of genenics</li>
</ul>
</div>

<div id="outline-container-org9fd2643" class="outline-4">
<h4 id="org9fd2643"><span class="section-number-4">3.4.1</span> calling methods from traits</h4>
<div class="outline-text-4" id="text-3-4-1">
<ul class="org-ul">
<li>you must `use` a trait to make it visible ie:</li>
</ul>

<div class="org-src-container">
<pre class="src src-rust">
use std::io::Read; // must include this

let mut s: Vec&lt;u8&gt; = "sad example".into();
let mut buf: [u8; 32] = [0; 32];
(&amp;s[..]).read(&amp;mut buf);

</pre>
</div>
</div>
</div>

<div id="outline-container-org3ed7ae3" class="outline-4">
<h4 id="org3ed7ae3"><span class="section-number-4">3.4.2</span> traits as parameters</h4>
<div class="outline-text-4" id="text-3-4-2">
<ul class="org-ul">
<li>this is not what I would consider a 'trait as parameter' but fine:</li>
</ul>

<div class="org-src-container">
<pre class="src src-rust">
fn save_record(kv: &amp;impl KeyValueStore) {
    //etc
}

</pre>
</div>

<p>
to me, the trait in this case constrains the parameter, it is not the
parameter itself. idk. 
</p>
</div>
</div>

<div id="outline-container-orge4427f7" class="outline-4">
<h4 id="orge4427f7"><span class="section-number-4">3.4.3</span> traits as return types</h4>
<div class="outline-text-4" id="text-3-4-3">
<ul class="org-ul">
<li>here the wording makes more sense. ex:</li>
</ul>

<div class="org-src-container">
<pre class="src src-rust">
fn create_in_memory_kvstore(config: Config) -&gt; impl KeyValueStore {
    todo!()
}

</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgea91656" class="outline-3">
<h3 id="orgea91656"><span class="section-number-3">3.5</span> Generics</h3>
<div class="outline-text-3" id="text-3-5">
<ul class="org-ul">
<li>generics allow code that accepts one or more type parameters. ex:</li>
</ul>

<div class="org-src-container">
<pre class="src src-rust">
fn max&lt;T: PartialOrd&gt;(x: T, y: T) -&gt; T {
    if x &gt; y {
       x
    } else {
       y
    }
}

fn main() {
    let a = 5;
    let b = 12;
    let c = 1.5;
    let d = 8.22;

    println!("Larger of {} and {}: {}", a, b, max(a, b));
    println!("Larger of {} and {}: {}", c, d, max(c ,d));

}

</pre>
</div>

<ul class="org-ul">
<li>generic structs</li>
</ul>

<div class="org-src-container">
<pre class="src src-rust">
struct Point&lt;T&gt; {
    x: T,
    y: T,
}

struct Point2&lt;X, Y&gt; {
    x: X,
    y: Y,
}

fn main() {

    let integer_point = Point { x = 1, y = 2};
    let float_point = Point { x = 1.2, y = 3.33};

    let mixed_point = Point2 { x = 1, y = 1.0}

}

</pre>
</div>

<ul class="org-ul">
<li>generic enums and traits. ex:</li>
</ul>

<div class="org-src-container">
<pre class="src src-rust">
use std::ops::Div;

enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}

// a 'generic' divide
fn divide&lt;T: Div&gt;(x: T, y: T) -&gt; T::Output {
   x / y
} 

</pre>
</div>
</div>
</div>

<div id="outline-container-orge401926" class="outline-3">
<h3 id="orge401926"><span class="section-number-3">3.6</span> Error Handling</h3>
<div class="outline-text-3" id="text-3-6">
<ul class="org-ul">
<li>Result and the ? operator. If ? is used, the calling function must
return a Result.</li>

<li>panics. reserved for exceptional situations where it is undesirable
or impossible to continue executing the program. to be used
sparingly and in exceptional circumstances. In most cases, Result is
better.</li>
</ul>
</div>
</div>

<div id="outline-container-org33dc0a3" class="outline-3">
<h3 id="org33dc0a3"><span class="section-number-3">3.7</span> Async/Await</h3>
<div class="outline-text-3" id="text-3-7">
<ul class="org-ul">
<li>concurrency and parallelism are not necessarily the same.</li>
<li>async defines asynchronous functions. they always return a
Future. This is a value that is not available yet, but will be at
some point. ex:</li>
</ul>

<div class="org-src-container">
<pre class="src src-rust">
async fn fetch_data() -&gt; Result&lt;String, String&gt; {
    // ...
}

</pre>
</div>

<p>
This functions says it returns a Result, but this is rust hiding some
details. The function doesn't return anything until you await it. When
a future is awaited, the current task is suspended, allowing other
tasks to run concurrently. ex:
</p>

<div class="org-src-container">
<pre class="src src-rust">
async fn main() {
    match fetch_data().await {
        Ok(data) =&gt; println!("Data: {}", data),
        Err(error) =&gt; println!("Error: {}", error),
    }
}

</pre>
</div>

<ul class="org-ul">
<li>async runtimes in rust: Tokio, but there are other options out
there.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org4a99437" class="outline-2">
<h2 id="org4a99437"><span class="section-number-2">4</span> Fin</h2>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: yoni</p>
<p class="date">Created: 2023-11-27 Mon 10:06</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
